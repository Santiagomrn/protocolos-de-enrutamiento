<!DOCTYPE html>
<html lang="en">
<head>
  <title>EIGRP</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="bootstrap-4.4.0-dist/css/bootstrap.min.css">

  <script src="bootstrap-4.4.0-dist/js/bootstrap.min.js"></script>
  <style>
  .fakeimg {
    height: 200px;
    background: #aaa;
  }
  #main{ 

    
    margin:0 auto;
    background-image: url("img/4.jpg");
    background-size: 100%;

 }
 div p {
    color: rgb(255, 255, 255);
    }
    div h1 {
    color: rgb(255, 255, 255);
    }
    div h2 {
    color: rgb(255, 255, 255);
    }
    div h3 {
    color: rgb(255, 255, 255);
    }
    div h4 {
    color: rgb(255, 255, 255);
    }
    div h5 {
    color: rgb(255, 255, 255);
    }


  #yt_header{
	background-image:url(img/1.jpg);
  height: 140px;
  }

.fakeimg {
  position: relative;
  width: 100%;
}
#hola {
  position: relative;
  width: 100%;
  height: 200px;
    background: #aaa;
}

.image {
  display: block;
  width: 100%;
  height: auto;
}

.overlay {
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
  background-color: rgba(8, 56, 112, 0.822);
  overflow:hidden;
  width: 100%;
  transition: .5s ease;
}

.fakeimg:hover .overlay {
  bottom: 0;
  height: 100%;
}

.text {
  color: white;
  font-size: 20px;
  position: absolute;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
  -ms-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  text-align: center;

}

body {
  font-family: Arial, Helvetica, sans-serif;
}

.flip-box {
  background-color: transparent;
  width: 800px;
  height: 420px;
  border: 1px solid #f1f1f1;
  perspective: 1000px;
}

.flip-box-inner {
  position: relative;
  width: 100%;
  height: 100%;
  text-align: center;
  transition: transform 0.8s;
  transform-style: preserve-3d;
}

.flip-box:hover .flip-box-inner {
  transform: rotateX(180deg);
}

.flip-box-front, .flip-box-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
}

.flip-box-front {
  background-color: #bbb;
  color: black;
}

.flip-box-back {
  background-color: rgba(0, 0, 0, 0.938);
  color: white;
  transform: rotateX(180deg);
}
#active{
  background-color: rgba(0, 0, 0, 0.938);
 
}

#punto{
  color: white;
 
}


  </style>
</head>
<body id="main">

<div id="yt_header" class="jumbotron text-center" style="margin-bottom:0">
</div>

<nav class="navbar navbar-expand-sm bg-dark navbar-dark" style="background-color: #00000000!important">
  

    <div  class="collapse navbar-collapse" id="collapsibleNavbar">
      <ul class="navbar-nav">
        <li class="nav-item" >
          <a class="nav-link" href="../index.html">Inicio</a>
        </li>
        <li class="nav-item" >
          <a class="nav-link" href="../RIP/RIP.html">RIP</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../OSPF/OSPF.html">OSPF</a>
        </li>
        <li class="nav-item" id="active">
          <a class="nav-link" href="EIGRP.html">EIGRP</a>
        </li>  
        <li class="nav-item">
          <a class="nav-link" href="../CREDITOS/CREDITOS.html">Créditos</a>
        </li>   
      </ul>
    </div>  
  </nav>

<div  class="container" style="margin-top:30px">
  <div class="row">
    <div class="col-sm-4">
      <h3>Redes de Computadoras</h3>
      <h5>Proyecto Final</h5>
      <div class="fakeimg">
        <img src="img/5.jpg" alt="Avatar" class="image" >
        <div class="container">
   
        </div>
      </div>
      <br><br><br>
      <nav class="navbar navbar-expand-sm bg-dark navbar-dark" style="background-color: #00000000!important">
  

        <div  class="collapse navbar-collapse" id="collapsibleNavbar">
          <ul class="navbar-nav">
            <li class="nav-item" >
              <a class="nav-link" href="../index.html">Inicio</a>
            </li>
            <li class="nav-item"  >
              <a class="nav-link" href="../RIP/RIP.html">RIP</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../OSPF/OSPF.html">OSPF</a>
            </li>
            <li class="nav-item" id="active">
              <a class="nav-link" href="../EIGRP/EIGRP.html">EIGRP</a>
            </li>  
            <li class="nav-item" >
              <a class="nav-link" href="../CREDITOS/CREDITOS.html"">Créditos</a>
            </li>   
          </ul>
        </div>  
      </nav>
      <hr class="d-sm-none">
    </div>
    <div class="col-sm-8">
      <h1>Enhanced Interior Gateway Routing Protocol</h1>
      <h5>¿Que es EIGRP?</h5>

      <p>El EIGRP es una versión mejorada de IGRP. La tecnología de vector de igual distancia que se usa en IGRP también se emplea en EIGRP. Además, la información de la distancia subyacente no presenta cambios. Las propiedades de convergencia y la eficacia de operación de este protocolo han mejorado significativamente. Esto permite una arquitectura mejorada y, a la vez, retiene la inversión existente en IGRP.

          La tecnología de convergencia está basada en una investigación realizada en SRI International. El algoritmo difusor de actualización (DUAL) es el algoritmo usado para obtener la loop-libertad en cada instante en un cómputo de la ruta. Esto les permite a todos los routers involucrados en una topología cambiar para sincronizarse al mismo tiempo. Los routers que no se ven afectados por los cambios de topología no se incluyen en el recálculo. El tiempo de convergencia con DUAL compite con el de cualquier otro protocolo de ruteo existente.
          
          EIGRP ha sido extendido para que sea independiente del protocolo de la capa de red, y así permita que DUAL soporte otros conjuntos de protocolos. </p>
      <br>
      <p>Más información detrás de la imagen</p>

      <div class="flip-box">
        <div class="flip-box-inner">
          <div class="flip-box-front">
            <img src="img/2.png" alt="Avatar" class="image" >
          </div>
          <div class="flip-box-back">
            <h2>Características</h2>
            <p  >EIGRP se basa en el principio clave del protocolo de routing vector distancia, según el cual la información acerca del resto de la red se obtiene a partir de vecinos conectados directamente.</p>
            <ol type=”A”>
              <li>Algoritmo de actualización difusa </li>
              <li>Establecimiento de adyacencias de vecinos </li>
              <li>Protocolo de transporte confiable </li>
              <li>Actualizaciones parciales y limitadas </li>
              <li>Balanceo de carga de mismo costo o con distinto costo</li>
            </ol>


            
          </div>
        </div>
      </div> 

      <br>
      <h2>Conceptos EIGRP</h2>
      <ol>
        <li id="punto">Tabla de Vecino</li>
        <p>Cada router conserva información de estado de los vecinos adyacentes. Cuando se reconoce a los vecinos recientemente detectados, se registra la dirección y la interfaz del vecino. Esta información está almacenada en la estructura de datos del vecino. La tabla de vecino contiene estas entradas. Hay una tabla de vecino para cada módulo dependiente del protocolo. Cuando un vecino envía un saludo, anuncia un tiempo de espera. HoldTime es la cantidad de tiempo que un router considera a un vecino como alcanzable y en funcionamiento. Es decir si un paquete de saludo no se oye dentro del holdtime, después del holdtime expira. Cuando la retención de tiempo caduca, se informa a DUAL sobre el cambio en la topología. </p>
        <li id="punto">Tabla de topología </li>
        <p>La Tabla de tipologías se completa mediante los módulos dependientes del protocolo y la máquina de estados finitos DUAL la pone en práctica. Contiene todos los destinos anunciados por los routers vecinos. Con cada entrada, está asociada la dirección de destino y una lista de vecinos que han anunciado el destino. Para cada vecino, se registra la métrica anunciada. Esta es la métrica que el vecino almacena en su tabla de ruteo. Si el vecino avisa este destino, debe estar utilizando la ruta para reenviar paquetes. Ésta es una regla importante que deben cumplir los protocolos del vector de distancia. </p>
        <li id="punto">Sucesores factibles</li>
        <p>Una entrada de destino se mueve desde la tabla de topología hasta la tabla de ruteo cuando existe un sucesor posible. Todos los trayectos de costo mínimo para un destino forman un conjunto. A partir de esto, los vecinos que tienen una medición anunciada menor que la medición de tabla de ruteo actual son considerados sucesores factibles. </p>
        <li id="punto">Estados de ruta</li>
        <p>Una entrada de la tabla de topología para un destino puede tener uno de dos estados. Una ruta se considera en el estado pasivo cuando un router no está realizando un recomputation de la ruta. La ruta está en el estado activo cuando un router está experimentando un recomputation de la ruta. Si siempre hay sucesores factibles, una ruta nunca tiene que ingresar a estado activo y evitar un recálculo de la ruta.</p>
        <li id="punto">Formatos de paquetes</li>
        <ol type=”A”>
          <li  id="punto">Hola/acks </li>
          <li  id="punto">Actualizaciones</li>
          <li  id="punto">Consultas</li>
          <li  id="punto">Contestaciones</li>
          <li  id="punto">Solicitudes</li>
        </ol>
        <li id="punto">Marcado de rutas</li>
        <p>EIGRP tiene la noción de rutas internas y externas. Rutas internas son aquellas que se originaron dentro de un sistema autónomo (AS) EIGRP. Por lo tanto, una red conectada en forma directa y configurada para ejecutar EIGRP se considera una ruta interna y se propaga junto con esta información a través del AS EIGRP. Las rutas externo son unas que han sido aprendidas por otro Routing Protocol o residen en la tabla de ruteo como Static rutas. Estas rutas son etiquetadas individualmente con la identidad de su origen. </p>
      </ol>
    </div>
  </div>
</div>



</body>
</html> 